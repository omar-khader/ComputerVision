# -*- coding: utf-8 -*-
"""Omar_Khader_PS1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nwcbfvFOboFijspmn7EjHS8OnFLkXK-t
"""

##imports
import numpy as np ##used for array math
import matplotlib.pyplot as plt ##used for plotting different views and seams
import imageio.v2 as imageio ## we need this for image read and write

##required functions
# First we need to calcualte the energy map of input image
# to do this we calculate the gradient in both x and y directions
# sobel operator 3 x 3 matric that is applied to image to calculate gradient
# then we use gradient at a cell to calcualte magnitude as sqrt(gx^2 + gy^2)

def find_energy(image):
  assert image.ndim == 3 and image.shape[2] == 3 ##checking that the image has all info we need RGB and M X N
  imf = image.astype(np.float64)/255.0 # normalizing values of the image
  #now we make it grey
  grey = (0.299 * imf[...,0] + 0.587 * imf[...,1] + 0.114 * imf[...,2]) ##multiplying each color R G B by standard luminance formula to get grey scale image
  gy, gx = np.gradient(grey) #calculating the gradiennt of the image using numpy
  energy = np.sqrt (gx*gx + gy*gy) ##setting the energy to the sqrt of gx^2 +gy^2
  return energy.astype(np.float64) ## returning the enery map as a float to maintain accruacy


## we must implement a dynamic method to find the vertical and horizontal seams that is in the paper and in class
##Each Verical we must add the Cells min of three parents from the previous row.
def Cumulative_min_energy_map(energyImg, SD):  ##seamdirection
  assert energyImg.ndim == 2 ## checking if the image is actually greyscale
  dir_up = SD.upper() ##setting the direction to whatever string we got in either "Horizontal or Vertical"

  if dir_up == 'VERTICAL':
    M, N = energyImg.shape ##take in the number of rows and columns
    Cumulative = np.zeros_like(energyImg, dtype=np.float64 ) ##create a new vector so that we can store the energy of the whole seam isntead of just one pixel to find the best seam
    Cumulative[0] = energyImg[0] ##starting the energy as just the energy for that first cell at the top
    ##then for the rest of the seam
    for i in range(1,M):
      ## we want to set the three parent pixels then choose the best and continue
      left = np.r_[np.inf, Cumulative[i-1, :-1]] ## the left parents is up to the left
      up = Cumulative[i-1] ##directly above
      right =np.r_[Cumulative[i-1, 1:],np.inf] #up to the right parent
      #find the best parent
      best = np.minimum(np.minimum(left, up), right)
      Cumulative[i] = energyImg[i] +best
    return Cumulative #the total energy of the seam with the minimal energy

  ## now we want direction checks to specify vertical or horizontal seams
  if dir_up == 'HORIZONTAL':
    return Cumulative_min_energy_map(energyImg.T, 'VERTICAL').T
  ##if we need to switch we use trnaspose which swaps rows andf columns
  raise ValueError("Direction must be 'VERTICAL' or 'HORIZONTAL'")


def find_vertical_seam(CumulativeEnergyMap):
  M ,N = CumulativeEnergyMap.shape
  seam = np.zeros(M, dtype=np.int32) ##array to hold the same pixels
  seam[-1] = int(np.argmin(CumulativeEnergyMap[-1])) #find the cheapest path starting from the bottom total energy row
  for i in range(M-2, -1, -1):
    j = seam[i+1]#only checking cell above
    j_left = max(j-1, 0)  ##checking cell to the left clamping at 0
    j_right = min(j+1, N-1) ##checking cell to right clamping n-1
    window = CumulativeEnergyMap[i, j_left:j_right+1] ##finding the cost of the 2-3 parents above so we can pick the cheapest
    seam[i] = j_left + int(np.argmin(window)) #finding the lowest energy cell from the columns to choose for the seam location per row
  return seam #update the seam


def find_horizontal_seam(CumulativeEnergyMap): #transposing for horizontal seams so again switching M and N
  return find_vertical_seam(CumulativeEnergyMap.T).astype(np.int32)


#Now we can do some actual carving
def decrease_width(image, energyImg_in):
  Cumulative = Cumulative_min_energy_map(energyImg_in, 'VERTICAL')
  seam = find_vertical_seam(Cumulative)
  M, N, _ = image.shape
  out = np.zeros((M, N-1, 3), dtype=image.dtype)
  for i in range(M):
    j = seam[i]
    out[i, :, :] = np.delete(image[i, :, :], j, axis=0)

  new_energy = find_energy(out)   ##recompute once after we finish removing the column
  return out, new_energy
 ##the new picture and the new calculated energy that theorettically should be lower
 # removing one horizontal seam (height shrinks by 1)
def decrease_height(image, energyImg_in):
  Cumulative = Cumulative_min_energy_map(energyImg_in, 'HORIZONTAL')  ##transpose logic inside
  seam = find_horizontal_seam(Cumulative)
  M, N, _ = image.shape
  out = np.zeros((M-1, N, 3), dtype=image.dtype)
  for j in range(N):                 ##for every column remove the chosen row
    i = seam[j]
    out[:, j, :] = np.delete(image[:, j, :], i, axis=0)
  new_energy = find_energy(out)
  return out, new_energy
  # show the chosen seam on top of an image (for plots)

def view_seam(im, seam, seamDirection):
  dir_up = seamDirection.upper()
  plt.imshow(im)
  if dir_up == 'VERTICAL':
    plt.plot(seam, np.arange(len(seam)), 'r-')   ##x=cols, y=rows
  elif dir_up == 'HORIZONTAL':
    plt.plot(np.arange(len(seam)), seam, 'b-')   ##x=cols, y=rows
  else:
    raise ValueError("Direction must be 'VERTICAL' or 'HORIZONTAL'")
  plt.axis('off'); plt.show()

##custom energy (Task 5) using Sobel but we implement the filtering ourselves no libraries
def _pad_reflect(img, ph, pw): 
  return np.pad(img, ((ph, ph), (pw, pw)), mode='reflect')  ##reflect padding so borders dont get weird

def _conv2d_same(gray, kernel):
  kh, kw = kernel.shape              ##kernel size 3x3 for sobel
  ph, pw = kh//2, kw//2              ##half sizes so we can keep same output size
  padded = _pad_reflect(gray, ph, pw)
  H, W = gray.shape
  out = np.zeros_like(gray, dtype=np.float64)
  k = np.flipud(np.fliplr(kernel))   ##flip for convolution math
  for i in range(H):                 ##slide the 3x3 window over every pixel
    for j in range(W):
      patch = padded[i:i+kh, j:j+kw] ##local neighborhood
      out[i, j] = np.sum(patch * k)  ##dot product = filtered value
  return out

def find_energy_sobel(image):
  assert image.ndim == 3 and image.shape[2] == 3  ##must be color MxNx3
  imf = image.astype(np.float64)/255.0            ##normalize to floats
  ##make it grey with standard luminance weights
  grey = (0.299*imf[...,0] + 0.587*imf[...,1] + 0.114*imf[...,2])

  ##Define Sobel kernels (x detects left↔right changes, y detects up↕down)
  sobel_x = np.array([[-1, 0, 1],
                      [-2, 0, 2],
                      [-1, 0, 1]], dtype=np.float64)
  sobel_y = np.array([[-1,-2,-1],
                      [ 0, 0, 0],
                      [ 1, 2, 1]], dtype=np.float64)

  ##apply our manual conv (no scipy) to get gradients
  gx = _conv2d_same(grey, sobel_x)
  gy = _conv2d_same(grey, sobel_y)

  ##energy is magnitude sqrt(gx^2 + gy^2) same as before
  energy = np.sqrt(gx*gx + gy*gy)
  return energy.astype(np.float64)

# Load the images (adjust paths as needed for your Colab environment)
# Note: In Google Colab, you may need to upload these files or mount your Google Drive
prague = imageio.imread("inputSeamCarvingPrague.jpg") #loading prague image
mall = imageio.imread("inputSeamCarvingMall.jpg") #loading mall image

# Demonstrate seam carving on Prague image
img = prague.copy()
plt.imshow(img); plt.title("OriginalPrague"); plt.axis('off'); plt.show()
E_prague = find_energy(prague)
plt.imshow(E_prague, cmap='gray'); plt.title("energyPrague"); plt.axis('off');plt.show()
CV = Cumulative_min_energy_map(E_prague, "VERTICAL")    #vertical cumulative map
CH = Cumulative_min_energy_map(E_prague, "HORIZONTAL")  #horizontal cumulative map
v_seam = find_vertical_seam(CV)
h_seam = find_horizontal_seam(CH)

plt.imshow(E_prague, cmap='gray'); plt.title("Vertical Seam on Energy Map"); plt.axis('off');
plt.plot(v_seam, np.arange(len(v_seam)), 'r-'); plt.show()

plt.imshow(E_prague, cmap='gray'); plt.title("Horizontal Seam on Energy Map"); plt.axis('off');
plt.plot(np.arange(len(h_seam)), h_seam, 'r-'); plt.show()

# Demonstrate seam carving on Mall image
img = mall.copy()
plt.imshow(img); plt.title("OriginalMall"); plt.axis('off'); plt.show()
E_mall = find_energy(mall)
plt.imshow(E_mall, cmap='gray'); plt.title("energyMall"); plt.axis('off');plt.show()

CV_mall = Cumulative_min_energy_map(E_mall, "VERTICAL")    #vertical cumulative map
CH_mall = Cumulative_min_energy_map(E_mall, "HORIZONTAL")  #horizontal cumulative map
v_seam_mall = find_vertical_seam(CV_mall)
h_seam_mall = find_horizontal_seam(CH_mall)

plt.imshow(E_mall, cmap='gray'); plt.title("Vertical Seam on Energy Map (Mall)"); plt.axis('off');
plt.plot(v_seam_mall, np.arange(len(v_seam_mall)), 'r-'); plt.show()

plt.imshow(E_mall, cmap='gray'); plt.title("Horizontal Seam on Energy Map (Mall)"); plt.axis('off');
plt.plot(np.arange(len(h_seam_mall)), h_seam_mall, 'r-'); plt.show()

#first we must reduce the width of both or either by 100 pixels
img = prague.copy()
e = find_energy(img)
for _ in range(100):
  img, e = decrease_width(img, e)
imageio.imwrite("OutputReducedWidthPrague.jpg", img)
plt.imshow(img); plt.title("OutputReducedWidthPrague"); plt.axis('off'); plt.show()

img = mall.copy()
e = find_energy(img)
for _ in range(100):
  img, e = decrease_width(img, e)
imageio.imwrite("OutputReducedWidthMall.jpg", img)
plt.imshow(img); plt.title("OutputReducedWidthMall");plt.axis('off'); plt.show()

# Task 5: Compare Sobel energy to np.gradient energy
print("\n=== Task 5: Sobel Filter Comparison ===")

# Calculate energy using Sobel filter
E_sobel = find_energy_sobel(prague)  ##new energy using sobel that we wrote ourselves
CV_s = Cumulative_min_energy_map(E_sobel, "VERTICAL")
CH_s = Cumulative_min_energy_map(E_sobel, "HORIZONTAL")
v_s = find_vertical_seam(CV_s)
h_s = find_horizontal_seam(CH_s)

# Display Sobel energy map and seams
plt.imshow(E_sobel, cmap='gray'); plt.title("EnergyPrague (Sobel)"); plt.axis('off'); plt.show()
plt.imshow(prague); plt.plot(v_s, np.arange(len(v_s)), 'r-'); plt.axis('off'); plt.title("Sobel Vertical Seam"); plt.show()
plt.imshow(prague); plt.plot(np.arange(len(h_s)), h_s, 'b-'); plt.axis('off'); plt.title("Sobel Horizontal Seam"); plt.show()

# Do the same for Mall image
E_sobel_mall = find_energy_sobel(mall)
CV_s_mall = Cumulative_min_energy_map(E_sobel_mall, "VERTICAL")
CH_s_mall = Cumulative_min_energy_map(E_sobel_mall, "HORIZONTAL")
v_s_mall = find_vertical_seam(CV_s_mall)
h_s_mall = find_horizontal_seam(CH_s_mall)

plt.imshow(E_sobel_mall, cmap='gray'); plt.title("EnergyMall (Sobel)"); plt.axis('off'); plt.show()
plt.imshow(mall); plt.plot(v_s_mall, np.arange(len(v_s_mall)), 'r-'); plt.axis('off'); plt.title("Sobel Vertical Seam (Mall)"); plt.show()
plt.imshow(mall); plt.plot(np.arange(len(h_s_mall)), h_s_mall, 'b-'); plt.axis('off'); plt.title("Sobel Horizontal Seam (Mall)"); plt.show()